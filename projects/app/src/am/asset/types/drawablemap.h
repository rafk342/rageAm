//
// File: drawablemap.h
//
// Copyright (C) 2023-2024 ranstar74. All rights violated.
//
// Part of "Rage Am" Research Project.
//
#pragma once

#include "am/types.h"
#include "am/graphics/geomprimitives.h"

class gtaDrawable;
struct CLightAttr;

namespace rage
{
	class rmcDrawable;
	class phBound;
	class crBoneData;
	class grmModel;
}

namespace rageam::asset
{
	// Absolute bound index in drawable, see DrawableAssetMap::GetBoundFromAbsoluteIndex
	// There's no really other way to define an index in such hierarchy
	// Imagine absolute index as index in bound tree view with all items unfolded (opened)
	using BoundAbsoluteIndex = int;

	struct BoundMaterialHandle
	{
		BoundAbsoluteIndex AbsoluteBoundIndex;
		// Index of material in phBoundGeometry::m_Materials (so in BVH)
		// -1 for all other primitive bound types
		int MaterialIndex;
	};

	/**
	 * \brief Maps 3D scene data to compiled gta drawable.
	 */
	struct DrawableAssetMap
	{
		static constexpr int MAX_LOD = 4;

		// SceneNode -> ### can be NULL
		// grmModel/phBound/crBoneData/grmShader/CLightAttr ALWAYS map to a valid scene index
		// BoneToSceneNode map to NULL index for autogenerated root bone

	private:
		// Internal function and may return NULL, in reality handle should never link nowhere, such handle is invalid
		rage::phBound* GetBoundFromAbsoluteIndexRecurse(rage::phBound* bound, BoundAbsoluteIndex absoluteIndex, int& currentIndex) const;
	public:
		// This function always returns a valid pointer
		rage::phBound* GetBoundFromAbsoluteIndex(rage::phBound* bound, BoundAbsoluteIndex absoluteIndex) const;

		List<s32>						SceneNodeToLOD;				// graphics::SceneNode		-> int
		List<List<BoundAbsoluteIndex>>	SceneNodeToBound;			// graphics::SceneNode		-> rage::phBound[]
		List<u16>						SceneNodeToModel[MAX_LOD];	// graphics::SceneNode		-> rage::grmModel
		List<u16>						SceneNodeToBone;			// graphics::SceneNode		-> rage::crBoneData
		List<bool>						SceneNodeToBoundIsInBVH;	// graphics::SceneNode		-> bool
		List<u16>						SceneNodeToLightAttr;		// graphics::SceneNode		-> CLightAttr
		List<graphics::PrimitiveType>	SceneNodeToBoundType;		// graphics::SceneNode		-> graphics::PrimitiveType (invalid for BVH / composite)
		List<u16>						SceneMaterialToShader;		// graphics::SceneMaterial	-> rage::grmShader
		List<List<BoundMaterialHandle>> SceneMaterialToBounds;		// graphics::SceneMaterial  -> rage::phBound[]

		List<u16>						ModelToSceneNode[MAX_LOD];	// rage::grmModel			-> graphics::SceneNode
		List<u16>						BoundToSceneNode;			// rage::phBound			-> graphics::SceneNode
		List<BoundAbsoluteIndex>		BoundToComposite;			// rage::phBound			-> rage::phBoundComposite (parent composite, if exists...)
		List<u16>						BoneToSceneNode;			// rage::crBoneData			-> graphics::SceneNode
		List<u16>						ShaderToSceneMaterial;		// rage::grmShader			-> graphics::SceneMaterial
		List<u16>						LightAttrToSceneNode;		// CLightAttr				-> graphics::SceneLight

		rage::grmModel*   GetModelFromScene(rage::rmcDrawable* drawable, u16 sceneNodeIndex) const;
		rage::crBoneData* GetBoneFromScene(const rage::rmcDrawable* drawable, u16 sceneNodeIndex) const;
		rage::phBound*    GetBoundFromScene(const gtaDrawable* drawable, u16 sceneNodeIndex, u16 arrayIndex) const;
		u16               GetBoundCountFromScene(const gtaDrawable* drawable, u16 sceneNodeIndex) const;
		CLightAttr*       GetLightFromScene(gtaDrawable* drawable, u16 sceneNodeIndex) const;

		u16 GetModelIndexFromScene(u16 nodeIndex)
		{
			int lod = SceneNodeToLOD[nodeIndex];
			if (lod == -1) return u16(-1);
			return SceneNodeToModel[lod][nodeIndex];
		}

		void Reset(int nodeCount, int materialCount);
		void AddNewNode();
		void AddNewMaterial();
		void DebugPrint() const;
	};
}
